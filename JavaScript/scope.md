# 스코프( scope )란 ?

**변수에 접근할 수 있는 범위**를 의미하는데 스코프를 알려면 모든 프로그래밍 언어의 확실한 이해가 필요하다.

```js
var x = "global";

function foo() {
  var x = "function scope";
  console.log(x);
}

foo(); // ?
console.log(x); // ?
```

foo 함수를 호출하면 `function scope`가 console에 찍히고
`console.log(x)`를 실행하면 `global`이 찍힌다.

스코프는 참조 대상 식별자를 찾아내기 위한 규칙이다. 자바스크립트는 이 규칙대로 식별자를 찾는다.

참조 대상 식별자? 변수, 함수 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름

변수는 전역 또는 코드 블록이나 함수 내에 선언하며 코드 블록이나 함수는 중첩될 수 있다. **식별자는 자신이 어디에서 선언됐는지에 의해 참조할 수 있는 범위를 갖는다.** 만약 이러한 범위가 없다면 어떻게 될까? 스코프가 없다면 같은 식별자 이름은 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없다. 스코프는 이와 같이 식별자 이름의 충돌을 방지한다.

## 스코프 구분

자바스크립트에서 스코프는 다음과 같이 2가지로 나눌 수 있다.

**전역 스코프**  
코드 어디에서든지 참조할 수 있다.

**지역 스코프**  
함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.

---

모든 변수는 스코프를 갖는다.

**전역 변수**  
전역에서 선언된 변수이며 어디에든 참조할 수 있다.

**지역 변수**  
지역(함수) 내에서 선언된 변수이며 그 지역과 그 지역으ㅢ 하부 지역에서만 참조할 수 있다.

전역 변수는 전역 스코프를 갖게 되고 지역 변수는 지역 스코프를 갖게 된다.

## 자바스크립트 스코프의 특징

자바스크립트의 스코프는 타 언어와는 다른 특징을 가지고 잇다.

대부분의 언어는 **블록 레벨 스코프**를 따른다.
블록 레벨 스코프란 코드 블록 {...}내에서 유효한(참조할 수 있는) 스코프를 의미한다.

```c
int main(void) {
  // block-level scope
  // if 내에서만 x 접근 가능.
  if (1) {
    int x = 5;
    printf("x = %d\n", x);
  }

  printf("x = %d\n", x); // use of undeclared identifier 'x'

  return 0;
}

```

하지만 자바스크립트는 **함수 레벨 스코프**를 따른다.
함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다는 것이다.

단, ES6에서 도입된 let을 사용한다면 **블록 레벨 스코프**를 사용할 수 있다.

```js
var x = 0;
{
  var x = 1;
  console.log(x); // 1
}
console.log(x); // 1

let y = 0;
{
  let y = 1;
  console.log(y); // 1
}
console.log(y); // 0
```

var = 함수 레벨 스코프  
let = 블록 레벨 스코프

## 전역 스코프

전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 전역 변수가 된다. var 키워드로 선언한 변수는 전역 객체 `window`의 프로퍼티 이다.

```js
var global = "global";

function foo() {
  var local = "local";
  console.log(global);
  console.log(local);
}
foo();

console.log(global);
console.log(local); // Uncaught ReferenceError: local is not defined
```

전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 사용을 자제하여야 한다.

## 비 블록 레벨 스코프

```js
var x = 1;

if (true) {
  var x = 5;
  console.log(x); // 5
}

function foo() {
  var x = "foo";
  console.log(x); // foo
}

foo();
console.log(x); // 5
```

변수 x는 코드 블록 내에서 선언되었다. 하지만 var는 함수 레벨 스코프를 사용하므로 **함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다할지라도 모두 전역 스코프**를 갖게 된다.

블록 레벨 스코프인 let이랑 비교하면 이해하기 쉽다.

```js
let x = 1;

if (true) {
  let x = 5;
  console.log(x); // 5
}

function foo() {
  let x = "foo";
  console.log(x); // foo
}

foo();
console.log(x); // 1
```

if나 함수 안에서의 x는 블록 안에서만 유효한 것을 볼 수 있다.

## 함수 레벨 스코프 (var)

```js
var a = 10; // 전역변수

(function () {
  var b = 20; // 지역변수
})();

console.log(a); // 10
console.log(b); // "b" is not defined
```

함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않다. 따라서 변수 b는 지역변수이다.

```js
var x = "global";

function foo() {
  var x = "local";
  console.log(x);
}

foo(); // local
console.log(x); // global
```

전역변수 x와 지역변수 x가 중복 선언되었다. 전역 영역에서는 전역변수만이 참조 가능하고 함수 내 지역 영역에서는 전역과 지역 변수 모두 참조 가능하나 위 예제와 같이 변수명이 중복된 경우, **지역변수를 우선하여 참조한다.**

다음은 함수 내에 존재하는 함수인 내부 함수의 경우를 살펴보자.

```js
var x = "global";

function foo() {
  var x = "local";
  console.log(x); // local

  function bar() {
    // 내부함수
    console.log(x); // local
  }

  bar();
}
foo();
console.log(x); // global
```

내부 함수는 자신을 포함하고 있는 외부 함수의 변수에 접근할 수 있다. bar 함수를 실행하면 foo 함수에서 선언한 x에 접근한 것을 볼 수 있다. 전역 변수 x가 뒤로 밀렸기 때문이다.

```js
var x = 10;

function foo() {
  console.log(x); // 10
  x = 100;
  console.log(x); // 100
}
foo();
console.log(x); // 100
```

함수(지역) 영역에서 전역변수를 참조할 수 있으므로 전역변수의 값도 변경할 수 있다. 내부 함수의 경우, 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능하다.

## 렉시컬 스코프

아래 예제의 실행 결과를 예측해보자.

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

나는 10 1 순서로 출력이 될 줄 알았는데 결과는 1 1 이었다.

위 예제의 실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있는데 첫번째는 **함수를 어디서 호출하였는지**에 따라 상위 스코프를 결정하는 것이고 두번째는 **함수를 어디서 선언**하였는지에 따라 상위 스코프를 결정하는 것이다.

첫번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고, 두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다.

프로그래밍 언어는 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다. 첫번째 방식을 **동적 스코프(Dynamic scope)**라 하고, 두번째 방식을 **렉시컬 스코프(Lexical scope)** 또는 **정적 스코프(Static scope)**라 한다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

동적 스코프 = 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것
정적 스코프 & 렉시컬 스코프 = 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것

자바스크립트 = 렉시컬 스코프

렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. **함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다.** 위 예제의 함수 bar는 전역에 선언되었다. 따라서 함수 bar의 상위 스코프는 전역 스코프이고 위 예제는 전역 변수 x의 값 1을 두번 출력한다.

## 암묵적 전역

```js
var x = 10; // 전역 변수

function foo() {
  // 선언하지 않은 식별자
  y = 20;
  console.log(x + y);
}

foo(); // 30
```

y는 선언하지 않은 식별자 이다. 따라서 y = 20이 실행되면 참조 에러가 발생할 것처럼 보인다. 하지만 선언하지 않은 식별자 y는 마치 선언된 변수처럼 동작한다. **이는 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기 때문이다.**

1. foo 함수가 호출되면 자바스크립트 엔진은 변수 y에 값을 할당하기 위해 먼저 스코프 체인을 통해 선언된 변수인지 확인한다.
2. 이때 foo 함수의 스코프와 전역 스코프 어디에서도 변수 y의 선언을 찾을 수 없으므로 참조 에러가 발생해야 하지만
3. 자바스크립트 엔진은 y = 20을 window.y = 20으로 해석하여 프로퍼티를 동적 생성한다.
4. 결국 y는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다.

이러한 현상을 **암묵적 전역(implicit global)**이라 한다.

이렇게 선언한 y는 프로퍼티로 추가되었을 뿐, 변수가 아니기 때문에 호이스팅이 발생하지 않는다.

## 최소한의 전역변수 사용

전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역변수 객체 하나를 만들어 사용하는 것이다. (더글라스 크락포드의 제안)

```js
var MYAPP = {};

MYAPP.student = {
  name: "Lee",
  gender: "male",
};

console.log(MYAPP.student.name);
```

## 즉시실행함수를 이용한 전역변수 사용 억제

전역변수 사용을 억제하기 위해, 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다. 이 방법을 사용하면 전역변수를 만들지 않으므로 라이브러리 등에 자주 사용된다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다.

```js
(function () {
  var MYAPP = {};

  MYAPP.student = {
    name: "Lee",
    gender: "male",
  };

  console.log(MYAPP.student.name);
})();

console.log(MYAPP.student.name);
```
