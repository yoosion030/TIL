# 정규 표현식

정규 표현식, 또는 정규식은 문자열에서 특정 문자 조합을 찾기 위한 패턴입니다. JavaScript에서는 정규 표현식도 객체로서, `RegExp`의 `exec()`와 `test()` 메서드를 사용할 수 있습니다.

## 정규 표현식 만들기

정규 표현식은 두 가지 방법으로 만들 수 있습니다.

- 정규 표현식 리터럴. 다음과 같이 슬래시로 패턴을 감싸서 작성합니다.

```js
const re = /ab+c/;
```

정규 표현식 리터럴은 스크립트 불러올 때 컴파일되므로, 바뀔 일이 없는 패턴의 경우 리터럴을 사용하면 성능이 향상될 수 있습니다.

- `RegExp`객체의 생성자 호출.

```js
const re = new RegExp("ab+c");
```

생성자 함수를 사용하면 정규 표현식이 런타임에 컴파일됩니다. 바뀔 수 있는 패턴이나, 사용자 입력 등 외부 출처에서 가져오는 패턴의 경우 이렇게 사용하세요.

## 정규 표현식 패턴 작성하기

1. 단순 패턴 사용하기 (/abc/)

   단순 패턴은 문자열을 있는 그대로 탐색할 때 사용합니다. 예를 들어, `/abc/` 패턴은 문자열에서 정확한 순서로 `"abc"`라는 문자의 조합이 나타나는 부분과 일치합니다. 그러므로 이 패턴은 `"Hi, do you know your abc's?"`와 `"The latest airplane designs evolved from slabcraft."` 두 문자열에서 일치에 성공하고, 일치하는 부분은 `"abc"`일 것입니다. 반면 `"Grab crab"`에서는 일치하지 않는데, 이 문자열은 부분 문자열로 `"ab c"`를 포함하긴 하지만, 정확하게 `"abc"`를 포함하지는 않기 때문입니다.

2. 특수 문자 사용하기 (/ab\*c/)

   하나 이상의 "b"를 찾는다거나 공백 문자를 찾는 등 직접적인 일치 이상의 탐색이 필요할 땐 특수 문자를 사용합니다. 예컨대 "하나의 `a` 이후에 0개 이상의 `b`, 그 뒤의 `c`"와 일치하면 `/ab*c/`패턴을 사용할 수 있습니다. `"b"`뒤의 `\*`는 **이전 항목의 0번 이상 반복을 의미**합니다. 이 패턴을 문자열 "cbbabbbbcdebc"에 대해 사용하면, 일치하는 부분 문자열은 "abbbbc"일 것입니다.

3. 이스케이핑 (/a\*b/)

   특수 문자를 있는 그대로 탐색("\*"을 직접 찾는 등)해야 하는 경우, **특수 문자 앞에 역슬래시(\\)를 배치**해서 이스케이프 해야 합니다. 예를 들어 "a" 뒤의 별표("\*") 뒤의 "b"와 일치해야 하면 `/a\*b/`를 사용하면 됩니다. 역슬래시가 "\*"를 **"이스케이프**"해서, 특수 문자가 아닌 문자 리터럴로 취급합니다.

   `RegExp` 생성자와 문자열 리터럴을 사용하는 경우, 역슬래시가 **문자열 리터럴의 이스케이프로도 작동한다는 것**을 기억해야 합니다. 그러므로 정규 표현식의 역슬래시를 나타내려면 문자열 리터럴 수준의 이스케이프도 해줘야 합니다. 즉, 앞서 살펴본 `/a\*b/` 패턴을 생성하려면 `new RegExp("a\\*b")`가 되어야 합니다.

## JavaScript에서 정규 표현식 사용하기

1. exec()
   문자열에서 일치하는 부분을 탐색합니다. 일치 정보를 나타내는 배열, 또는 일치하는 경우가 없는 경우 `null`을 반환합니다.

2. test()
   문자열에 일치하는 부분이 있는지 확인합니다. `true`또는 `false`를 반환합니다.
3. replace()
   문자열에서 일치하는 부분을 탐색하고, 그 부분을 대체 문자열로 바꿉니다.
4. replaceAll()
   문자열에서 일치하는 부분을 모두 탐색하고, 모두 대체 문자열로 바꿉니다.
5. split()
   정규 표현식 또는 문자열 리터럴을 사용해서 문자열을 부분 문자열의 배열로 나눕니다.

### 활용

1.  문자열에 숫자만 있는지 확인 (/^[0-9]+$/)

    ```js
    const regex = /^[0-9]+$/;
    let str = "aaaa123";
    console.log(regex.test(str)); // false
    str = "aA가나다라B123ㄱㄱㄱ";
    console.log(regex.test(str)); // false
    str = "123";
    console.log(regex.test(str)); // true
    ```

2.  문자열에 알파벳만 있는지 확인 (/^[a-z|A-Z]+$/)

    ```js
    const regex = /^[a-z|A-Z]+$/;

    let str = "aaaa123";
    console.log(regex.test(str)); // false

    str = "123가나다";
    console.log(regex.test(str)); // false

    str = "aAAAbb";
    console.log(regex.test(str)); // true
    ```

3.  문자열에 한글만 있는지 확인 (/^[ㄱ-ㅎ|가-힣]+$/)

    ```js
    const regex = /^[ㄱ-ㅎ|가-힣]+$/;

    let str = "aaaa123";
    console.log(regex.test(str)); // false

    str = "123가나다";
    console.log(regex.test(str)); // false

    str = "가나다라";
    console.log(regex.test(str)); // true
    ```
