# 2.1 HTTP는 클라이언트와 서버 간에 통신을 한다.

TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버 간에 통신을 합니다. 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 됩니다.

HTTP를 사용하여 2대의 컴퓨터 간에 통신을 하는 경우, 한 번 통신을 할 때마다 반드시 어느 한 쪽은 클라이언트가 되고 다른 한 쪽은 서버가 됩니다.

HTTP를 사용하여 2대의 컴퓨터 간에 통신을 하는 경우, 한 번 통신을 할 때마다 반드시 어느 한 쪽은 클라이언트가 되고 다른 한 쪽은 서버가 된다.  
경우에 다라서는 2개의 컴퓨터 간에 클라이언트와 서버가 바뀌는 일도 있을 수 있지만, 한 번 통신했을 때만 본다면 클라이언트와 서버의 역할은 반드시 정해여 있습니다. HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있습니다.

# 2.2 리퀘스트와 리스폰스를 교환하여 성립

HTTP는 클라이언트로부터 **리퀘스트**(요청, Request)가 송신되며, 그 결과가 서버로부터 **리스폰스**(응답, Response)로 되돌아옵니다. 즉, 반드시 클라이언트 측으로부터 통신이 시작됩니다. 서버 측은 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일은 없습니다.  
서버 측은 리퀘스트를 수신하지 않으면 리스폰스가 발생하는 경우는 없습니다.

# 2.3 상태를 유지하지 않는 프로토콜

HTTP는 상태를 계속 유지하지 않는 **스테이트리스(stateless) 프로토콜**입니다. HTTP 프로토콜 독자적으로, 리퀘스트와 리스폰스를 교환하는 동안에 상태(status)를 관리하지 않습니다. 결국, HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않습니다.

HTTP에서는 새로는 리퀘스트가 보내질 때마다 새로운 리스폰스가 생성됩니다. 프로토콜로서는 과거의 리퀘스트나 리스폰스 정보를 전혀 가지고 있지 않습니다. 이는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성을 확보하기 위해서 이와 같이 간단하게 설계되어 있는 것입니다.  
그러나 웹이 진화함에 따라, 스테이트리스 특성만으로는 처리하기 어려운 일이 증가하게 되었습니다. 예를 들면, 쇼핑 사이트에 **로그인**했을 때입니다. 다른 페이지로 이동하더라도 로그인 상태를 유지할 필요가 있습니다. 이를 위해서는 누가 어떤 리퀘스트를 보냈는지를 파악하기 위해 상태를 유지할 필요가 있습니다.  
HTTP/1.1은 상태를 유지하지 않는 프로토콜입니다. 그래서 상태를 계속 유지하고 싶은 요구에 부응하기 위해서 **쿠키(Cookie)**라는 기술이 도입되었습니다. 쿠키로 인해 HTTP를 이용한 통신에서도 상태를 계속 관리할 수 있게 되엇습니다.

# 2.4 리퀘스트 URI로 리소스를 식별

HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정합니다. 이 URI가 있는 덕분에 인터넷 상의 어떤 장소에 있는 리소스를 호출할 수 있습니다.

클라이언트는 리소스를 호출할 때 마다 리퀘스트를 송신할 때에 리퀘스트 안에 URI라고 불리는 형식으로 포함해야 할 필요가 있습니다. 리퀘스트 URI를 지정하는 방법에는 여러 종류가 있습니다.

# 2.5 서버에 임무를 부여하는 HTTP메소드

### GET: 리소스 획득

GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구합니다. 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과입니다. 결국 리소스가 텍스트이면 그대로 반환하고 GGI와 같은 프로그램이면 실행해서 출력된 내용을 돌려줍니다.

### POST: 엔티티 전송

POST 메소드는 엔티티를 전송하기 위해서 사용됩니다.  
GET으로도 엔티티를 전송할 수 있지만, 자주 사용하지 않고 일반적으로 POST를 사용합니다. POST는 GET과 기능이 비슷하지만 리스폰스에 의한 엔티티를 획득하는 것만이 목적은 아닙니다.

### PUT: 파일 전송

PUT 메소드는 파일을 전송하기 위해서 사용됩니다. FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구합니다.

단지, PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제도 있어서 일반적인 웹 사이트에서는 사용되지 않고 있습니다. 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST(Repersentational State Transfer)와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있습니다.

### HEAD: 메시지 헤더 취득

HEAD 메소드는 GET과 같은 기능이지만 메시지 바디는 돌려주지 않습니다. URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용됩니다.

### DELETE: 파일 삭제

DELETE 메소드는 파일을 삭제하기 위해 사용됩니다. PUT 메소드와는 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구합니다.  
단지, DELETE 자체에는 PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되고 있지 안ㄹ습니다. 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST를 사용하는 경우에 사용되는 경우가 있습니다.

# 2.6 메소드를 사용해서 지시를 내리다.

리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에는 메소드라고 불리는 명령이 있습니다. 메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재합니다. 메소드에는 GET과 POST, DELETE 등이 있습니다.

# 2.7 지속 연결로 접속량을 절약

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었습니다.

초기 당시의 통신에서는 작은 사이즈의 텍스트를 보내는 정도였기 때문에, 이렇게 기능을 구현해도 문제는 없었습니다. 그러나 HTTP가 널리 보급되어감에따라, 다량의 이미지를 포함한 문서 등이 늘어났습니다. 예를 들면, 하나의 HTML에 여러 이미지가 포함되어 있는 경우 브라우저를 사용해서 리퀘스트를 하면 HTML문서에 포함되어있는 이미지를 획득하기 위해서 여러 리퀘스트를 송신합니다. 그렇기 때문에 리퀘스트를 보낼 때마다 매번 TCP 연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 됩니다.

## 2.7.1 지속 연결(Persistent Connections)

HTTP/1.1와 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해서 **지속 연결**이라는 방법을 고안하였습니다. 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 **TCP연결을 계속 유지**합니다.

지속 연결을 하는 이점은 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감됩니다. 도한, 오버헤드를 줄인 만큼 HTTP 리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있습니다.

이러한 지속 연결은 HTTP/1.1에서는 표준 동작이지만 HTTP/1.0에서는 정식 사양이 아니었습니다. 일부 서버에서는 사양에 없는 기능을 구현해서 지속 연결을 가능하게 한 것도 있지만 반드시 지속 연결이 지원되고 있다고는 할 수 없습니다. 물론, 클라이언트도 지속 연결을 지원할 필요가 없습니다.

## 2.7.2 파이프라인화(HTTP pipelining)

지속 연결은 여러 리퀘스트를 보낼 수 있도록 **파이프라인화**를 가능하게 합니다. 파이프라인화에 의해서, 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, **리스폰스를 기자리지 않고 바로 다음 리퀘스트를 보낼 수 있습니다.**

이로 인해, 여러 리퀘스트를 병행해서 보내는 것이 가능하기 때문에 일일이 리스폰스를 기다릴 필요가 없습니다.

예를 들면, HTML 한 페이지에 10개의 이미지를 포함한 웹 페이지를 리퀘스트한 경우에는 개별 연결보다 지속 연결이 리퀘스트 완료가 빠르고, 게다가 지속 연결 보다 파이프라인화 쪽이 빠릅니다. 이 차이는 리퀘스트의 수가 늘어날수록 현저하게 나타납니다.

# 2.8 쿠키를 사용한 상태 관리

HTTP는 stateless 프로토콜이기 때문에, **과거에 교환했었던 리쿼스트와 리스폰스의 상태를 관리하지 않습니다.** 결국, 과거 상태를 근거로해서 현재 리퀘스트를 처리한다는 것은 불가능합니다.

예를 들면, 인증이 필요한 웹 페이지에서 상태 관리를 하지 않는다면 인증을 마친 상태를 잊어버리기 때문에 새로운 페이지로 이동할 때마다 재차 로그인 정보를 보내든지 리퀘스트마다 매개 변수나 추가 정보를 붙여서 로그인 상태를 관리해야 하는 상황이 발생합니다.

물론 stateless 프로토콜에도 이점이 있습니다. 상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있습니다. 또한, 단순한 프로토콜이기에 HTTP가 다양한 곳에서 이용되는 측면도 있습니다.

stateless 프로토콜이라는 특징은 남겨둔 채, 이와 같은 문제를 해결하기 위해 쿠키라는 시스템이 도입되었습니다.

> 쿠키란 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템입니다.

쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신합니다. 서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 알 수 있습니다.
