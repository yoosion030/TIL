# 타입스크립트 입문 - 기초부터 실전까지 강의 정리

## 타입스크립트란?

타입스크립트는 자바스크립트에 타입을 부여한 언어이다. 자바스크립트의 확장된 언어로 자바스크립트 슈퍼셋으로 볼 수 있습니다.

### 타입스크립트를 써야하는 이유

- 에러의 사전 방지

```js
// math.js
function sum(a, b) {
  return a + b;
}
```

```ts
// math.ts
function sum(a: number, b: number) {
  return a + b;
}
```

두 코드 숫자의 합을 구하는 코드입니다.

```js
sum("a", 10);
```

만약 이렇게 함수 인자에 문자열이 들어가면 어떻게 될까요? 자바스크립트에서는 문자열이랑 숫자열 연산이 되어 `a10`이 출력될 것입니다.  
하지만 타입스크립트를 사용하면 인자에 number만 들어올 수 있다고 에러를 알려주어 사전에 방지할 수 있는 장점이 있습니다.

- 코드 가이드 및 자동 완성

```js
// math.js
function sum(a, b) {
  return a + b;
}
var total = sum(10, 20);
total.toLocaleString();
```

위 코드는 앞에서 살펴봤던 sum() 함수를 이용하여 두 숫자의 합을 구한 다음 toLocaleString()(특정 언어의 표현 방식에 맞게 숫자를 표기하는 API)를 적용한 코드입니다.
자바스크립트에서는 total 값이 number인지 확실하지 않기때문에 `toLocalString()`을 호출하려면 일일이 다 작성해야한다.

```js
function sum(a: number, b: number): number {
  return a + b;
}
var total = sum(10, 20);
total.toLocaleString();
```

하지만 타입스크립트를 사용하면 `total`이 `number`인 걸 알기때문에 number상태에서 사용할 수 있는 API 자동완성을 제공해줍니다.

## 타입스크립트 기본 타입

타입스크립트의 기본 타입에는 크게 12가지가 있습니다.

- Boolean
- Number
- String
- Object
- Array
- Tuple
- Enum
- Any
- Void
- Null
- Undefined
- Never

### String

자바스크립트 변수의 타입이 **문자열**인 경우 아래와 같이 선언해서 사용합니다.

```ts
let str: string = "hi";
```

### Number

타입이 **숫자**이면 아래와 같이 선언합니다.

```ts
let num: number = 10;
```

### Boolean

타입이 진위 값이면 아래와 같이 선언합니다.

```ts
let isLogged: boolean = false;
```

### Object

타입이 오브젝트 값이면 아래와 같이 선언합니다.

```ts
// TS 객체
let obg: object = {};
```

하지만 이렇게만 선언해주면 세부 타입이 뭔지 모릅니다.

```ts
let person: object = {
  name: "capt", // name은 무슨 타입?
  age: 10,
};
```

그럴 때 세부 타입도 지정해줄 수 있습니다.

```ts
let person2: { name: string; age: number } = {
  name: "capt",
  age: 10,
};
```

### Array

타입이 배열인 경우 아래와 같이 선언합니다.

```ts
let arr: number[] = [1, 2, 3];
```

```ts
let arr: Array<number> = [1, 2, 3];
```

**++ 읽기 전용 배열**

첫 선언시에만 값을 할당하고 변경이 불가한 읽기 전용 배열을 생성할 수 있습니다.  
`ReadonlyArray<T>`

```ts
let arr: ReadonlyArray<number> = [1, 2, 3];
arr.splice(0, 1); // error
arr.push(4); // error
arr[0] = 100; // error
```

### Tuple

튜플은 배열의 길이가 고정이고 각 요소의 타입이 지정되어 있는 배열 형식을 의미합니다.

```ts
let arr: [string, number] = ["hi", 10];
```

### Enum

이넘은 특정 값들의 집합을 의미합니다.

```ts
enum Avengers {
  Capt = "capt",
  IronMan = "IronMan",
  Thor = "Thor",
}
let hero: Avengers = Avengers.Capt;
```

이넘은 인덱스 번호로도 접근할 수 있습니다.

```ts
enum Avengers {
  Capt = "capt",
  IronMan = "IronMan",
  Thor = "Thor",
}
let hero: Avengers = Avengers[0];
```

### Void

변수에는 `undefined`와 `null` 그리고 함수에서 반환 값이 없을 때 아래와 같이 선언합니다.

```ts
let unuseful: void = undefined;
function notuse(): void {
  console.log("sth");
}
```

### Never

함수의 끝에 절대 도달하지 않는다는 의미를 지닌 타입입니다.

```ts
function neverEnd(): never {
  while (true) {}
}
```

## 타입스크립트에서의 함수

웹 애플리케이션을 구현할 때 자주 사용되는 함수는 타입스크립트로 크게 다음 3가지 타입을 정의할 수 있습니다.

- 함수의 **파라미터(매개변수)** 타입
- 함수의 **반환** 타입
- 함수의 **구조** 타입

### 함수의 기본적인 타입선언

자바스크립트에서의 함수

```js
function sum(a, b) {
  return a + b;
}
```

타입스크립트에서의 함수

```ts
function sum(a: number, b: number): number {
  return a + b;
}
```

타입스크립트에서의 함수는 자바스크립트에서의 함수와 다르게 **매개변수**와 함수의 **반환 값**에 타입을 지정해줄 수 있습니다. 이 때 반환 값이 없다면 `void` 타입을 사용합니다.

### 함수의 인자

타입스크립트에서는 함수의 인자를 모두 필수 값으로 간주합니다.

```ts
function sum(a: number, b: number): number {
  return a + b;
}
```

```ts
// OK
sum(10, 20);

// NO!
sum(10);
sum(10, 20, 30);
```

sum 함수의 인자는 2개인데 1개 혹은 3개 이렇게 인자를 넘겨버리면 에러가납니다. 따라서, 함수의 매개변수를 설정하면 undefined나 null이라도 인자로 넘겨야 하고 또한 타입도 맞춰 넘겨주어야 합니다.

만약 인자가 2개 혹은 1개라면 `?`를 이용하여 아래와 같이 정의할 수 있습니다.

```ts
function sum(a: number, b?: number): number {
  return a + b;
}
```

매개변수 초기화는 ES6 문법과 동일합니다.

```ts
function sum(a: number, b = "100"): number {
  return a + b;
}
sum(10, undefined); // 110
sum(10, 20, 30); // error, too many parameters
sum(10); // 110
```

## 인터페이스

인터페이스는 상호 간에 정의한 약속 혹은 규칙을 의미합니다. 타입스크립트에서의 인터페이스는 보통 다음과 같은 범주에 대해 약속을 정의할 수 있습니다.

- 객체의 스펙 (속성과 속성의 타입)
- 함수의 파라미터
- 함수의 스펙(파라미터, 반환 타입 등)
- 배열과 객체를 접근하는 방식
- 클래스

### 인터페이스 예제

```ts
interface Person {
  age: number;
  name: string;
}

let person: Person = { name: "Capt", age: 28 };
```

이렇게 객체의 속성 타입을 인터페이스로 선언해줄 수 있습니다.

### 옵션 속성

인터페이스를 사용할 때 인터페이스에 정의되어 있는 속성을 모두 다 사용하지 않아도 됩니다.

```ts
interface InterfaceName {
  속성?: 타입;
}
```

이렇게 속성 끝에 `?`를 붙이면 됩니다.

### 옵션 속성의 장점

옵션 속성의 장점은 단순히 인터페이스를 사용할 대 속성을 선택적으로 적용할 수 있다는 것 뿐만 아니라 인터페이스에 정의되어 있지 않은 속성에 대해서 인지시켜줄 수 있다는 점입니다.

```ts
interface CraftBeer {
  name: string;
  hop?: number;
}

let myBeer = {
  name: "Saporo",
};
function brewBeer(beer: CraftBeer) {
  console.log(beer.brewery); // Error: Property 'brewery' does not exist on type 'Beer'
}
brewBeer(myBeer);
```

위에 보시는 것처럼 인터페이스에 정의되어 있지 않은 속성에 대해서 오류를 표시합니다.

### 읽기 전용 속성

읽기 전용 속성은 인터페이스로 객체를 처음 생성할 때만 값을 할당하고 그 이후에는 변경할 수 없는 속성을 의미합니다.

```ts
interface CraftBeer {
  readonly brand: string;
}
```

인터페이스로 객체를 선언하고 나서 수정하려고 하면 아래와 같이 오류가 납니다.

```ts
let myBeer: CraftBeer = {
  brand: "Belgian Monk",
};
myBeer.brand = "Korean Carpenter"; // error!
```

만약 인터페이스 정의하지 않은 속성들을 추가로 사용하고 싶을 때는 아래와 같은 방법을 사용합니다.

```ts
interface CraftBeer {
  brand?: string;
  [propName: string]: any;
}
```

이러면 brand 속성 이외에 다른 속성들이 any 타입으로 들어올 수도 있습니다.

### 함수 타입

인터페이스는 함수의 타입을 정의할 때에도 사용할 수 있습니다.

```ts
interface login {
  (username: string, password: string): boolean;
}

let loginUser: login;
loginUser = function (id: string, pw: string) {
  console.log("로그인 했습니다");
  return true;
};
```

### 인터페이스 확장

클래스와 마찬가지로 인터페이스도 인터페이스 간 확장이 가능합니다.

```ts
interface Person {
  name: string;
}

interface Teacher extends Person {
  subject: string;
}

interface Developer extends Person {
  skills: string;
}

let sion: Developer = { name: "sion", skills: "ts" };
```
