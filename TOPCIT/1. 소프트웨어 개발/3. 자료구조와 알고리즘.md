# 1-3. 자료구조와 알고리즘

## 자로구조 정의

자료구조란 자료를 컴퓨터의 기억장치 내에 저장하는 방법으로 다양한 자료를 효율적으로 표현하고 활용할 수 있도록 자료의 특성과 사용 용도를 고려하여 조직적, 체계적으로 정의한 것이다.

## 자료구조 분류

- 선형구조
  원시코드로부터 정보를 추출하여 물리적 설계 정보저장소에 저장.  
  물리적 설계자료들이 직선 형태로 나열되어 자료들 간의 순서를 고려한 구조로 전후/인접/선후 자료들 간의 1:1관계로 나열됨.  
  종류로는 배열, 선형리스트, 연결리스트, 스택, 큐, 데크 등이 있음.
- 비 선형구조
  한 자료 뒤에 여러 개의 자료들이 존재하는 구조로 인접/전후 자료들 간의 1:다 또는 다:다 관계로 배치됨.  
  종류로는 트리와 그래프 등이 있음

## 스택과 큐

1. 스택(Stack)
   스택은 선형리스트의 하나로 데이터가 입력된 순서로 기억공간에 저장되어 출력 시 가장 나중에 쌓인 데이터가 가장 먼저 출력을 하게 되는 자료구조(Last In First Out)이다. 즉, 스택에 저장된 원소는 top으로 정한 곳에서만 접근이 가능하여 top 위치에서만 원소를 삽입하고 마지막에 삽입한 원소는 맨 위에 쌓여있다가 가장 먼저 출력하게 된다.

- top(): 스택의 맨 위에 있는 데이터 값을 반환한다.
- push(): 스택에 데이터를 삽입한다.
- pop(): 스택에서 데이터를 삭제하여 반환하다.
- isempty(): 스택에 원소가 없으면 true값을 반환하고 있으면 false 값을 반환한다.
- isfull(): 스택에 원소가 없으면 false값을 반환하고 있으면 true값을 반환한다.

2. 큐(Queue)
   스택과 유사하게 삽입과 삭제의 위치가 제한되어 있지만 스택과는 달리 데이터가 삽입되는 곳과 삭제되는 곳이 다른 자료구조이다. 큐는 뒤에서만 삽입되고 앞에서는 삭제만 할 수 있는 구조로 삽입된 순서대로 원소가 나열되어 가장 먼저 삽입한 원소는 맨 앞에 있다가 가장 먼저 삭제된다.

- enQueue: 큐에 데이터를 삽입한다. rear를 움직여 큐의 공간을 확보한 후 데이터를 삽입한다.
- deQueue: 큐에서 데이터를 삭제한다. front를 움직여 가장 오래된 데이터를 다음 번째 데이터로 넘기게 된다.

## 트리와 그래프

1. 트리(Tree)

원소들 간에 계층관계를 가지는 계층형 자료 구조로 상위원소에서 하위원소로 내려하면서 확장되는 나무 모양의 구조를 가지고 있으며 원소들 간에 1:다 관계를 가진다.

트리의 시작노드를 루트노드라고 하고 노드를 연결하는 선을 간선이라고 한다. 같은 부모노드를 가진 자식노드들을 형제노드라고하고 부모노드와 연결된 간선을 끊었을 때 생성되는 트리를 서브트리라고 한다.

2. 그래프(Graph)
   연결되어 있는 원소 사이의 다:다 관계를 표현하는 자료구조로 객체를 나타내는 정점과 객체를 연결하는 간선의 집합이다. 그래프 자료구조는 전기회로분석, 최단거리 검색, 인공지능 등과 같이 여러가지 복잡한 문제들을 그래프로 나타내어 그래프이론을 기반으로 문제를 해결하는 경우가 많다.

- 무방향 그래프
- 방향 그래프
- 완전 그래프
- 가중 그래프

## 자료구조의 활용

1. 리스트: 배열의 구현, DBMS 인덱스, 탐색이나 정렬과 같은 문제 등
2. 스택: 인터럽트 처리, 재귀 프로그램의 순서 제어, 서브루틴의 복귀 번지 저장, 후위 표기법으로 표현된 수식의 연산, 텍스트 에디터 Undo 등
3. 큐 : 운영체제의 작업 스케줄링, 대기 행렬의 처리, 비동기 데이터 교환, 키보드 버퍼 이용, 스풀 운용 등
4. 데크 : 스택과 큐의 장점만 활용한 자료구조로 스택과 큐 관련 분야에서 활용
5. 트리 : 탐색이나 정렬과 같은 문제, 문법의 파싱, 허프만 코드, 결정트리, 게임 등
6. 그래프 : 컴퓨터 네트워크, 전기회로 분석, 이항 관계, 연립 방정식 등

## 알고리즘의 정의

알고리즘이란 주어진 문제를 해결하기 위한 일련의 처리 절차를 단계적으로 기술한 것으로 문제 해결 방법을 추상화하여 단계적 절차를 논리적으로 기술해 놓은 명세서이다. 알고리즘의 목표는 단순히 원하는 결과를 얻을 수 있는 알고리즘이 아닌 처리시간이나 기억장소 사용 측면에서 효율적인 알고리즘을 개발하는 것이다.

## 알고리즘의 조건

- 입력 : 알고리즘 수행에 필요한 자료가 외부에서 0개 이상 입력으로 제공될 수 있어야 한다.
- 출력 : 알고리즘 수행 후 하나 이상의 결과를 출력해야 한다.
- 명확성 : 수행할 작업의 내용과 순서를 나타내는 알고리즘의 각 처리 단계의 명령어들은 명확하게 명세되어야 한다.
- 유한성 : 알고리즘은 수행 후에 반드시 종료되어야 한다.
- 효과성 : 알고리즘의 모든 명령어들은 기본적이며 실행이 가능해야 한다.

## 알고리즘 분석 기준

1. 정확성

알고리즘이 타당한 입력에 대해서 유한 시간 내에 올바른 결과를 산출하는가를 판단한다.

2. 작업량

알고리즘을 수행하는데 걸리는 수행 횟수를 나타내며, 전체 알고리즘에서 기본으로 포함되는 일반 연산을 제외하고 흐름의 핵심이 되는 중요한 연산들만으로 작업량을 측정한다.

3. 기억 장소 사용량

알고리즘이 수행되는 동안 데이터와 정보 등을 저장하기 위해 필요한 컴퓨터 메모리의 사용량을 의미한다.

4. 최적성

"어떤 알고리줌이 최적이다."라고 하는 것은 알고리즘을 적용할 시스템의 사용 환경을 고려 할 때 그 알고리즘보다 더 적합한 알고리즘이 없다는 것을 의미한다.

5. 단순성

알고리즘의 표현이 얼마나 이해하기 쉽게 명확하게 작성되었는지를 의미한다. 알고리즘이 단순하며 알고리즘의 정확성을 증명하는 것과 프로그램의 작성 및 디버깅이 수월하다.

## 알고리즘 성능 분석

알고리즘의 성능 분석은 실행에 필요한 공간 측면에서 분석하는 공간 복잡도와 실행에 소요되는 시간 측면에서 분석하는 시간 복잡도를 추정하여 일반적인 평가를 한다.

1. 공간 복잡도

알고리즘을 프로그램으로 실행하여 완료하기까지 필요한 총 저장 공간을 의미하며 고정 공간량과 가변 공간량의 합으로 구할 수 있다.

```
공간 복잡도 = 고정 공간량 + 가변 공간량
```

2. 시간 복잡도

알고리즘을 프로그램으로 실행하여 완료하는 데 걸리는 시간으로 컴파일시간과 실행시간의 합으로 구한다.

```
시간 복잡도 = 컴파일시간 + 실행시간
```

## 정렬 알고리즘

1. 정렬의 분류

정렬 장소에 따라 분류할 수 있다. 정렬 방법은 사용하는 시스템의 특성, 데이터의 양과 상태, 정렬에 필요한 기억 공간 및 실행 시간 등의 조건을 고려하여 선택한다.

- 내부정렬 : 소량의 데이터에 대해 주기억 장치에 올려서 정렬하는 방식으로 정렬 속도는 빠르나 주기억 장치의 용량에 의해 정렬할 수 있는 데이터의 양이 제한됨
- 외부정렬 : 대량의 데이터에 대해 보조 기억 장치에서 정렬하는 방식으로 대량의 데이터를 몇 개의 서브 파일로 나누어 내부 정렬을 한 후 보조 기억 장치에서 정렬된 각 서븨 파일들을 병합하는 방식으로 속도가 느림

2. 버블정렬

선택정렬처럼 제일 큰 원소를 끝자리로 옮기는 작업을 반복하지만 제일 큰 원소를 오른쪽으로 옮길 대 왼쪽에 이웃한 수를 비교하면서 순서가 제대로 되어 있지 않으면 자리를 바꾸어 진행하는 정렬알고리즘이다.

## 검색 알고리즘

데이터 집합에서 원하는 항목을 효율적으로 찾는 기법으로 데이터의 정렬 여부에 따라 순차검색 과 제어검색으로 구분할 수 있다. 또한 특정 함수에 따라 키 값을 계산하여 데이터를 검색하는 해싱도 있다. 따라서, 자료구조의 형태 및 자료의 배열 상태를 고려하여 최적의 탐색 방법을 선택해야 한다.

## 그래프 탐색 알고리즘

1. 그래프 탐색
2. 깊이 우선 탐색
3. 너비 우선 탐색
