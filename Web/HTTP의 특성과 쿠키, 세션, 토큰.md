# HTTP의 특성과 쿠키, 세션, 토큰

## HTTP, 웹의 동작과정

![](https://images.velog.io/images/bumsu0211/post/e99e48bf-4c80-487c-a66b-29c50fdb13b0/Untitled.png)

클라이언트는 서버에게 **요청**을 하고, 서버는에게 **응답**을 받는다.  
각기 다른 클라이언트들이 하나의 서버에 요청을 보낼 수 있는데, 모두 다른 방식으로 요청을 보내면 서버가 일일이 대응할 수 없다. 따라서 **HTTP**라는 통신규약을 지정하여 모든 요청과 응답은 HTTP 양식에 맞게 보내야 한다.

## 특성

### Connectionless

HTTP 통신을 하기 위해서는 **클라이언트와 서버가 연결이 되어있어야 한다.**  
하지만 이 커넥션을 유지하는 것 자체도 부담이고, 클라이언트가 늘어나서 커넥션의 개수가 많아지면 서버에 많은 부담이 된다.  
따라서**HTTP 통신을 한번 할 때 클라이언트와 서버를 연결하고, 통신이 끝나면 바로 연결을 끊게한다.** 한 클라이언트가 여러번의 요청을 보내도 연결을 끊어졌다, 연결됐다를 반복하는 특성을 **Connectionless** 라고 한다.

**장점**

- 서버의 부하를 줄여서 더 많은 클라이언트의 요청을 처리할 수 있다.

**단점**

- 연결을 계속 끊어버리기 때문에 여러번 요청한 클라이언트와 **연결을 계속 새로 만들어주어야한다.**

## Stateless

HTTP는 이전 요청의 상태를 기록하지 않기 때문에 **서버는 클라이언트를 식별할 수 없다.**  
커넥션이 계속 연결되어 있으면 요청을 보낸 클라이언트가 누구인지 지속적으로 파악할 수 있지만, Connectionless 특성때문에 계속 연결이 끊어져 어떤 클라이언트가 요청을 했는지 알 수 없다.

또한 **"서버는 클라이언트의 상태를 보존하지 않는다."** 즉, 이전 요청이 어떻게 끝났느냐에 따라 다음 요청이 영향을 받지 않고 모든 요청이 독립적이다. 따라서 서버는 클라이언트를 식별할 수 없다.

**장점**

- 이전 요청을 기억할 필요가 없으므로, 이를 위한 저장 공간이 필요없다.
- 서버 디자인을 단순하게 만들 수 있다.
- 서버가 여려대의 컴퓨터로 구성된 경우, 어떠한 컴퓨터가 요청을 받더라도 응답이 가능하다.

**단점**

- 클라이언트를 식별하기 어렵다.
- 매 요청마다 추가 정보를 주어야 한다.

## 웹의 개인화

웹이 발전함에 따라 각 클라이언트에 맞게 개인화된 웹 사이트를 제공해야할 때가 많아지고 있다.

- 만약 쇼핑몰 사이트에서 신발을 많이 검색한 사람에게는 신발을 추천 상품으로 보여주기
- 신규 유저인 경우, 웰컴 메세지 보여주기
- "7일간 보지 않기"를 선택한 유저에게는 팝업을 띄워주지 않기
- 기본 배송지, 아이디 저장 기능 등

개인화를 위해서 여러 클라이언트들을 서버가 식별할 수 있어야 했다. HTTP는 **Connectionless**, **Stateless**였으므로 **클라이언트를 식별할 수가 없었고**, 초기 웹 개발자들은 클라이언트를 식별하기 위한 방법들을 각기 개발했다.

### HTTP Header

HTTP 헤더의 정보를 분석하여 사용자를 어느정도 구분할 수 있다.

- From : 사용자의 이메일 주소
- User-Agent : 사용자의 브러우저 정보
- Referer : 사이트에 유입된 경로

클라이언트로부터 요청이 들어왔을 때, 위 정보들을 사용하여 이 클라이언트가 이저에 방문한 어떤 클라이언트와 같은지 식별하였다. 그러나 HTTP Header로 확실하게 식별하기엔 정보가 부족하다.

### IP 추적

초기에는 IP 주소를 이용해 클라이언트를 식별하려고 했었지만 **IP는 컴퓨터를 식별하는 것**이지 실제 사용자를 식별할 수가 없었다. 여러 사람이 하나의 IP로 접근할 수도 있고 한 사람이 여러 개의 IP로 접근할 수도 있다.

### 로그인

웹 서버가 클라이언트에게 인증 정보를 요청하는 방식인 로그인을 통해 클라이언트를 식별할 수 있다.
그러나 매 요청마다 인증 정보를 요구하는 것은 사용자 입장에서 너무 귀찮은 일이고 모든 페이지를 전환할 때마다 정보를 요청하면 사용자에게 불편함을 줄수도 있다.

### Fat URL

URL에 고유 ID를 넣어 클라이언트를 식별하는 방법이다. 클라이언트가 웹 사이트에 방문한 첫 요청에 서버는 고유 ID를 발행하고, 그 값을 URL에 계속 넣어둔다. 사이트 내에서 페이지 이동이 일어나도 해당 아이디를 꼭 URL에 포함시켜서 클라이언트 추적을 놓치지 않도록 한다.

**단점**

- URL이 보기 싫어진다.
- **URL을 공유할 수 없다.**
- **URL을 유지하지 못하고 이탈할 가능성이 크다.** 사용자가 다른 사이트를 방문하고 다시 돌아오거나, 고유 ID가 누락된 링크를 클릭하면 해당 클라이언트에 대한 식별은 끝이 난다.

## ⭐해결법⭐

위 방식들의 한계로 새로운 클라이언트 식별법이 필요하였고, 넷스케이프에서 **쿠키**를 개발하였다.
