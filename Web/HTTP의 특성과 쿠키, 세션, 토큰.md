# HTTP의 특성과 쿠키, 세션, 토큰

## HTTP, 웹의 동작과정

![](https://images.velog.io/images/bumsu0211/post/e99e48bf-4c80-487c-a66b-29c50fdb13b0/Untitled.png)

클라이언트는 서버에게 **요청**을 하고, 서버는에게 **응답**을 받는다.  
각기 다른 클라이언트들이 하나의 서버에 요청을 보낼 수 있는데, 모두 다른 방식으로 요청을 보내면 서버가 일일이 대응할 수 없다. 따라서 **HTTP**라는 통신규약을 지정하여 모든 요청과 응답은 HTTP 양식에 맞게 보내야 한다.

## 특성

### Connectionless

HTTP 통신을 하기 위해서는 **클라이언트와 서버가 연결이 되어있어야 한다.**  
하지만 이 커넥션을 유지하는 것 자체도 부담이고, 클라이언트가 늘어나서 커넥션의 개수가 많아지면 서버에 많은 부담이 된다.  
따라서**HTTP 통신을 한번 할 때 클라이언트와 서버를 연결하고, 통신이 끝나면 바로 연결을 끊게한다.** 한 클라이언트가 여러번의 요청을 보내도 연결을 끊어졌다, 연결됐다를 반복하는 특성을 **Connectionless** 라고 한다.

**장점**

- 서버의 부하를 줄여서 더 많은 클라이언트의 요청을 처리할 수 있다.

**단점**

- 연결을 계속 끊어버리기 때문에 여러번 요청한 클라이언트와 **연결을 계속 새로 만들어주어야한다.**

### Stateless

HTTP는 이전 요청의 상태를 기록하지 않기 때문에 **서버는 클라이언트를 식별할 수 없다.**  
커넥션이 계속 연결되어 있으면 요청을 보낸 클라이언트가 누구인지 지속적으로 파악할 수 있지만, Connectionless 특성때문에 계속 연결이 끊어져 어떤 클라이언트가 요청을 했는지 알 수 없다.

또한 **"서버는 클라이언트의 상태를 보존하지 않는다."** 즉, 이전 요청이 어떻게 끝났느냐에 따라 다음 요청이 영향을 받지 않고 모든 요청이 독립적이다. 따라서 서버는 클라이언트를 식별할 수 없다.

**장점**

- 이전 요청을 기억할 필요가 없으므로, 이를 위한 저장 공간이 필요없다.
- 서버 디자인을 단순하게 만들 수 있다.
- 서버가 여려대의 컴퓨터로 구성된 경우, 어떠한 컴퓨터가 요청을 받더라도 응답이 가능하다.

**단점**

- 클라이언트를 식별하기 어렵다.
- 매 요청마다 추가 정보를 주어야 한다.

## 웹의 개인화

웹이 발전함에 따라 각 클라이언트에 맞게 개인화된 웹 사이트를 제공해야할 때가 많아지고 있다.

- 만약 쇼핑몰 사이트에서 신발을 많이 검색한 사람에게는 신발을 추천 상품으로 보여주기
- 신규 유저인 경우, 웰컴 메세지 보여주기
- "7일간 보지 않기"를 선택한 유저에게는 팝업을 띄워주지 않기
- 기본 배송지, 아이디 저장 기능 등

개인화를 위해서 여러 클라이언트들을 서버가 식별할 수 있어야 했다. HTTP는 **Connectionless**, **Stateless**였으므로 **클라이언트를 식별할 수가 없었고**, 초기 웹 개발자들은 클라이언트를 식별하기 위한 방법들을 각기 개발했다.

### HTTP Header

HTTP 헤더의 정보를 분석하여 사용자를 어느정도 구분할 수 있다.

- From : 사용자의 이메일 주소
- User-Agent : 사용자의 브러우저 정보
- Referer : 사이트에 유입된 경로

클라이언트로부터 요청이 들어왔을 때, 위 정보들을 사용하여 이 클라이언트가 이저에 방문한 어떤 클라이언트와 같은지 식별하였다. 그러나 HTTP Header로 확실하게 식별하기엔 정보가 부족하다.

### IP 추적

초기에는 IP 주소를 이용해 클라이언트를 식별하려고 했었지만 **IP는 컴퓨터를 식별하는 것**이지 실제 사용자를 식별할 수가 없었다. 여러 사람이 하나의 IP로 접근할 수도 있고 한 사람이 여러 개의 IP로 접근할 수도 있다.

### 로그인

웹 서버가 클라이언트에게 인증 정보를 요청하는 방식인 로그인을 통해 클라이언트를 식별할 수 있다.
그러나 매 요청마다 인증 정보를 요구하는 것은 사용자 입장에서 너무 귀찮은 일이고 모든 페이지를 전환할 때마다 정보를 요청하면 사용자에게 불편함을 줄수도 있다.

### Fat URL

URL에 고유 ID를 넣어 클라이언트를 식별하는 방법이다. 클라이언트가 웹 사이트에 방문한 첫 요청에 서버는 고유 ID를 발행하고, 그 값을 URL에 계속 넣어둔다. 사이트 내에서 페이지 이동이 일어나도 해당 아이디를 꼭 URL에 포함시켜서 클라이언트 추적을 놓치지 않도록 한다.

**단점**

- URL이 보기 싫어진다.
- **URL을 공유할 수 없다.**
- **URL을 유지하지 못하고 이탈할 가능성이 크다.** 사용자가 다른 사이트를 방문하고 다시 돌아오거나, 고유 ID가 누락된 링크를 클릭하면 해당 클라이언트에 대한 식별은 끝이 난다.

## ⭐해결법⭐

위 방식들의 한계로 새로운 클라이언트 식별법이 필요하였고, 넷스케이프에서 **쿠키**를 개발하였다.

---

## 쿠키의 동작 방식

HTTP 쿠키는 서버가 클라이언트에게 준 정보를 브라우저에 저장하고, 클라이언트가 요청을 보낼 때 HTTP 헤더에 정보를 담아서 서버에 전달한다.
![](https://images.velog.io/images/bumsu0211/post/91067f38-b000-4055-95ea-24a081004098/Untitled%206.png)

### 1. 클라이언트의 첫 HTTP Request

클라이언트가 웹 사이트를 첫 방문하면 서버는 해당 클라이언트를 식별하기 위한 Key-Value객체를 만든다.

### 2. 서버의 HTTP Response

HTTP 헤더의 **Set-Cookie** 항목에 쿠키를 담아서 전달한다. 클라이언트는 Set-Cookie 헤더에있는 쿠키를 브라우저에 저장한다.  
Set-Cookie말고도 쿠키를 세팅할 수 있는 방법이 있다. 서버에서 렌더링하는 HTML에 정보를 전달하고 script태그 내에서 쿠키를 세팅할 수 있다. 사용자가 어떤 버튼을 눌렀을 때 자바스트립트를 통해 쿠키를 서버 개입없이 세팅해놓을수도 있다.

```JS
<script>
  setCookie({
    name: 'status',
    value: '{{ user.status }}',
    expires: new Date('2021-09-30 23:59:59'),
    .
    .
  })
</script>
```

### 3. 클라이언트의 HTTP Request + Cookie

클라이언트의 첫 요청 이후, 다음 요청부터는 쿠키가 HTTP 헤더에 포함된다. 브라우저가 가지고 있는 쿠키의 개수는 몇백개가 되는데, 모든 사이트를 방문하거나 API 요청을 보낼 때마다 몇백개의 쿠키를 HTTP 헤더에 담아서 보내지는 않는다.

**쿠키의 속성**

- **Domain** : HTTP 요청을 보내 주소의 도메인이 Domain 속성값과 같은 경우에만 쿠키를 보낸다.
- **Path** : HTTP 요청을 보낼 주소의 URL 경로가 Path 속성값과 같은 경우에만 쿠키를 보낸다.

이렇게 쿠키를 서버로 보내서 서버가 클라이언트를 식별할 수 있도록 한다.

### HTTP Status Management Mechanism

쿠키의 기본발상은 브라우저가 서버의 정보를 저장하고 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하는 것이다.

저장된 서버 정보가 쿠키이고 브라우저는 쿠키를 저장할 책임이 있다. 이러한 시스템을 **"클라이언트 측 상태"**, **"HTTP 상태 관리 체계"**라고 한다.

---

## 쿠키의 종류

### 세션쿠키

- 만료일을 설정하지 않기 때문에 브라우저를 종료하면 파기된다.
- 사용자가 사이트를 탐색할 때 선호 사항, 임시설정 등을 저장하는 쿠키
  - 최근 본 상품
  - 최근 검색어

### 지속 쿠키

- 디스크에 저장돼서 만료일까지는 브라우저를 끄거나 재부팅해도 남아있는다.
- 다음 방문에도 영향을 주는 설정정보나 로그인 등을 유지할 때 사용하는 쿠키
  - 일주일간 팝업보지 않기
  - 로그인 유지

---

## 쿠키의 제약조건과 한계

### 쿠키의 제약조건

- 브라우저는 총 300개의 쿠키를 저장할 수 있다.
- 하나의 도메인당 20개의 쿠키를 가질 수 있다. 초과되면 가장 적게 사용된 것부터 삭제한다.
- 하나의 쿠키는 최대 4KB까지의 용량을 차지한다.

### 쿠키의 한계

- 민감한 정보를 그대로 HTTP통신에 노출하는 경우 탈취당할 수 있다. 아이디와 패스워드를 쿠키에 넣어서 모든 요청마다 인증정보를 포함하게 할 수 있는데 통신 과정에서 패킷을 가로채가면 패스워드가 유출될 수 있다.

## ⭐해결법⭐

쿠키의 보안 취약점을 보안하기 위해 **"세션"**이 등장한다.

---

## 세션의 동작방식

쿠키가 탈취당할 수 있다는 것을 인지하여 민감한 정보는 서버에만 저장하고 쿠키에는 서버에 저장된 정보를 찾을 수 있는 키만 전달하는 방식이다.  
쿠키를 사용하는 것에는 변함이 없고 쿠키 값으로 어떤 것을 주느냐가 다르다.

### 1. 클라이언트의 첫 HTTP Request와 세션 생성

쿠키의 동작방식과 같이 클라이언트가 첫 요청을 보내면 서버는 이 클라이언트를 식별하기 위한 객체를 만든다. 쿠키에서는 이 객체를 바로 HTTP 헤더에 담아서 보내지만, 세션에서는 이를 서버에 저장한다. DB에 저장할 수도 있고, 서버의 파일 시스템에 저장할 수 있다. 이렇게 세션이 저장되는 공간을 **세션 스토리지**라고 한다.

### 2.서버의 HTTP Response

서버는 세션 스토리지에 저장된 정보를 식별할 수 있는 세션 ID를 쿠키에 담아서 클라이언트에게 전달한다. 세션 스토리지가 데이터베이스라고 한다면 쿠키가 담고있는 값은 단지 데이터베이스의 어떤 로우를 가리키는 PK일 뿐이다. 다라서 쿠키가 탈취당해도 쿠키로부터 얻을 수 있는 정보는 없다.

### 3. HTTP with Session
